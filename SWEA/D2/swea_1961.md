### 1961.숫자 배열 회전

#### 풀이

```python
T = int(input())

for tc in range(1, T+1):
    N = int(input())
    arr = [[0] for _ in range(N)]
    result = []
    for i in range(N):
        arr[i] = list(map(int, input().split()))
    n = 0
    while n < 3:
        dst = [[0]*N for _ in range(N)]
        for i in range(N):
            for j in range(N):
                dst[j][N-1-i] = arr[i][j]
        result.append(dst)
        arr = dst
        n += 1

    print(f'#{tc}')
    for i in range(N):
        for j in range(3):
            for k in range(N):
                print(result[j][i][k], end='')
            print(end=' ')
        print()
```

#### 문제를 풀면서 힘들었던 점 & 고민했던 것

> 행렬이 나오면 조금 쫀다. 왜냐면 지난 주에 했던 [1258.행렬찾기]문제가 너무 어려웠었기 때문 ..

1. 먼저 N x N 행렬을 각각 90도, 180도, 270도로 회전한 행렬을 ㄱㄴㄷ순으로 나열해서 프린트하는 문제였다.

2. 간단히 3X3행렬을 가지고 고민을 해봤다.

3. 가장 먼저 드는 생각은 가운데 5의 자리는 변하지 않는다는 것이었다.

4. 그리고 90도를 한번 돌리면, 해당 행렬을 다시 90도 돌린 것과 같은 알고리즘을 실행하면 180도가 되고, 한 번 더하면 270도가 되니 90도로 회전하는 것이 핵심이라고 생각했다.

5. 하지만 그 이후로는 떠오르는게 없어서 각각의 자리를 직접 적어봤다.

   ex. [[1 2 3], [4 5 6], [7 8 9]] 이와 같은 행렬이 있을 때, 1의 자리는 [0 0], 2의 자리는 [0 1], 3의 자리는 [0 2], 등 .. 이런식으로 생각해봤다.

6. 그렇게 했더니 알고리즘이 보였다.

   90도 회전의 경우

   [0 0] -> [0 2], [0 1] -> [1 2], [0 2] -> [2 2]

   [1 0] -> [0 1], [1 1] -> [1 1], [1 2] -> [2 1]

   [0 2] -> [2 0], [2 1] -> [1 0], [2 2] -> [2 0]

   각각의 자리를 [n m]이라고 하고 행렬의 길이를 N이라고 한다면

   1. 처음에는 n과 m의 자리를 바꾸고 어떻게 하는 것 같았다.
   2. n 자리에 m 값을 넣고 m자리에 임의 값을 넣는 것 같이 보였다.
   3. 자세히 보니, [n m] -> [m, N-1-n] 의 형태로 바뀐다는 것을 알 수 있었다.

7. 해당 알고리즘에 맞추어 코드를 짜봤는데, 처음에 fail이 떴다.

8. 그 이유는 3X3에 너무 집중한 나머지, 모든 코드를 N값을 기준으로 짰기 때문(while과 j의 범위)

   

   



